{
	"compilerOptions": {
		//* Группа Strict Checks
		/*Все вышеперечисленные флаги по умолчанию имеют значение false, а для того, чтобы было строго нужно установить противоположное значение – true.*/
		"strict": false, //? Рекомендован: всегда / сложность: сложно / может быть заменён набором других флагов.
		/* Флаг strict напрямую связан с проверкой типов. Его включение автоматически активирует абсолютно все флаги секции Strict Checks*/
		"alwaysStrict": true, //? Рекомендован: всегда / сложность: легко.
		/* Включает добавление строки "use strict" в каждый скомпилированный файл. Другими словами, alwaysStrict включает строгий режим JavaScript
		и никак не связан с проверкой типов TypeScript.*/
		"noImplicitAny": true, //? Рекомендую: всегда / сложность: средне
		/* Несколько слов про any. Это специальный тип, который назначается всем переменным, если их тип не был задан явно и не может быть
		 выведен компилятором автоматически. Данный тип создан для обратной совместимости с JavaScript. С точки зрения TypeScript, все переменные 
		 JavaScript это any, поскольку в нём нет системы типов.*/
		"strictNullChecks": true, //? Рекомендую: всегда / сложность: средне
		/* Обрабатывать ситуации с undefined и null в тех участках кода, где возникновение данных значений невозможно. При этом в тем местах,
		где возникновение подобных ситуаций возможно, компилятор не позволит забыть о проверках. Это очень сильный механизм, существование которого сложно переоценить.*/
		"strictFunctionTypes": true, //? Рекомендую: всегда / сложность: легко
		/* Установка флага strictFunctionTypes: true включает более строгую проверку сигнатур функций. В целом, данная опция выглядит достаточно обязательной для использования:*/
		"strictPropertyInitialization": true, //? Рекомендую: всегда / сложность: легко / связан с strictNullChecks
		/* Флаг strictPropertyInitialization следит, чтобы объявленные свойства класса всегда были инициализированы:
		Опция является своего рода дополнением к флагу strictNullChecks поэтому работает только когда второй флаг тоже включен.*/
		"noImplicitThis": true, //? Рекомендую: всегда / сложность: легко
		/* При использовании this проверяет, что контекст выполнения известен.*/
		"strictBindCallApply": true, //? Рекомендую: всегда / сложность: средне
		/* Флаг strictBindCallApply – включает более строгую проверку сигнатур при использовании соответствующих методов: bind, call, apply.*/
		//
		//* Группа Linter Checks
		/* Флаги этой группы проверяют не соответствие типов, а качество кода. Своего рода правила как в ESLint.*/
		"noPropertyAccessFromIndexSignature": true, //? Рекомендую: всегда / сложность: легко / есть нюанс / нельзя заменить линтером
		/* Запрещает обращаться к свойствам объекта через точку aka dot notation, если свойства объекта описаны не явно, а через произвольные параметры
		(aka arbitrarily-named properties, index signatures).*/
		"noUncheckedIndexedAccess": false, //? Рекомендую: по ситуации / сложность: средне / есть серьёзный нюанс / связан с strictNullChecks / нельзя заменить линтером
		//
		"noImplicitReturns": true, //? Рекомендую: всегда / сложность: легко / правило ESLint: consistent-return, пока не реализовано
		/* Флаг проверяет, чтобы все ветки функции возвращали значение*/
		"noFallthroughCasesInSwitch": true, //? Рекомендую: если не используется ESLint / сложность: легко / правило ESLint: no-fallthrough
		// Флаг проверяет наличие break в операторе switch/case
		"noUnusedLocals": false, //? Рекомендую: для production если не используется ESLint / сложность: легко / правило ESLint: no-unused-vars
		/* Код проверяется на наличие неиспользуемых переменных
		Данное правило крайне неудобно при использовании в процессе разработки. В процессе написания кода он может находится в «разобранном» состоянии,
		а наличие неиспользуемых переменных будет вызывать ошибку компиляции.*/
		"noUnusedParameters": false, //? Рекомендую: для production если не используется ESLint / сложность: легко / правило ESLint: no-unused-vars
		/* Код проверяется на наличие неиспользуемых аргументов функций и методов
		Данное правило также как noUnusedParameters мешает удобному процессу разработки. Можно переопределять флаг для development окружения или добавить
		дополнительные параметры к проверке ESLint no-unused-vars.*/
		//* Группа Advanced
		"allowUnreachableCode": true, //? Рекомендую: всегда для production / сложность: легко / правило ESLint: no-unreachable, пока не реализовано
		/* Флаг запрещает недосягаемый код – код, написанный после операторов return, throw, break, continue*/
		"allowUnusedLabels": true, //? Рекомендую: для production если не используется ESLint / сложность: легко / правило ESLint: no-unused-labels
		/* Опция запрещает неиспользуемые лэйблы. Не думаю, что можно встретить данную синтаксическую конструкцию в наши дни, но тем не менее:*/
		//
		"noImplicitUseStrict": false, //? Настроен по умолчанию, изменять противопоказано / связан с alwaysStrict
		/* Флаг автоматически добавляет "use strict" если target версия меньше, чем ES6. Опция alwaysStrict в свою очередь делает тоже самое,
		но для любых target. Вряд ли когда-нибудь возникнет необходимость переопределять значение данного флага.*/
		"suppressExcessPropertyErrors": false, //? Настроен по умолчанию, изменять противопоказано
		/* Флаг проверяет, чтобы объект не мог содержать свойства, которые не были описаны в его структуре*/
		"suppressImplicitAnyIndexErrors": false, //? Настроен по умолчанию, изменять противопоказано / связан с noImplicitAny
		/* Флаг проверяет, что используя скобочную нотацию невозможно обращаться к свойствам объекта, которые в нём не объявлены ни явно, ни через
		произвольные параметры.*/
		"noStrictGenericChecks": false, //? Настроен по умолчанию, изменять противопоказано
		/* Переопределение данного флага может сделать компилятор «более лояльным» при работе с generics*/
	}
}