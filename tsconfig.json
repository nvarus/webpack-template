{
	//* Секция root
	"extends": "./tsconfig-checks.json", //? Type: string | false, default: false.
	/* Указывает путь к файлу из которого нужно унаследовать опции. По большей части, служит инструментом	упорядочивания.
	Можно разделить опции по некой логике, чтобы они не смешивались. Например, вынести настройки строгости в отдельный файл*/
	//"files": [], //? Type: string[] | false, default: false, связана с include.
	/*Указать список конкретных файлов для компиляции
	Данная опция подходит лишь для совсем маленьких проектов из нескольких файлов.*/
	"include": [ //? Type string[], default: зависит от значения files, связана с exclude.
		"ts/**/*",
		"tests/**/*",
		"src/**/*"
	],
	// Если опция files не указана, то TypeScript будет использовать эту директиву для поиска компилируемых файлов.
	// Если include так же не указана, то её значение будет неявно объявлено как ["**/*"]. Это означает, что поиск файлов будет
	// осуществляться во всех папках и их подпапках. Такое поведение не оптимально, поэтому в целях производительности лучше всегда
	// указывать конкретные пути. Можно прописывать как пути к конкретным файлам, так и паттерны путей.
	//"exclude": [], //? Type: string[], default: ["node_modules", "bower_components", "jspm_packages"].
	/* Директива служит для того, чтобы исключать некоторые лишние пути или файлы, которые включились директивой include. По умолчанию,
опция имеет значение путей пакетных менеджеров npm, bower и jspm, так как модули в них уже собраны. Помимо этого, TypeScript 
будет так же игнорировать папку из опции outDir, если она указана.*/
	//
	//* Секция компилятора
	"compilerOptions": {
		"removeComments": false,
		"preserveConstEnums": true,
		"sourceMap": false,
		"target": "ES5", //? Type: string, default: ES3, влияет на опции lib, module.
		/* Cтандарт ECMAScript: ES3, ES5, ES6 (он же ES2015), ES2016, ES2017, ES2018, ES2019, ES2020
		Для backend приложений/пакетов подойдёт ES6, если рассчитываете только на современные версии Node.js и ES5,
		если хотите поддержать более старые версии. На данный момент стандарт ES6, с небольшими оговорками, 
		поддерживается 97.29% браузеров. Так что для frontend приложений ситуация аналогичная.*/
		"module": "ES2015", //? Type: string, default: зависит от target, влияет на опцию moduleResolution
		/* Модульная система, которую будет использовать ваше собранное приложение
		На выбор: None, CommonJS, AMD, System, UMD, ES6, ES2015, ES2020 или ESNext
		Для backend приложений/пакетов подойдёт ES6 или CommonJS в зависимости от версий Node.js,
		которые хотите поддерживать. Для frontend приложений под современные браузеры также подходит ES6.
		А для поддержки более старых браузеров и для изоморфных приложений, определённо стоит выбрать UMD.*/
		"moduleResolution": "node", //? Type: string, default: зависит от module.
		/* Стратегия, которая будет использоваться для импорта модулей. Здесь всего две опции: node и classic.
		При этом classic в 99% не будет использоваться, так как это legacy. Однако, я специально упомянул этот флаг,
		так как он меняется в зависимости от предыдущего флага. При изменении значения module режим moduleResolution
		может переключиться на classic и в консоли начнут появляться сообщения об ошибках на строчках с импортами.
		Во избежание описанной ситуации, я рекомендую всегда явно указывать значение node для данного флага.*/
		//"lib": [] //? Type: string[], default: зависит от target.
		/* В зависимости от того какой target установлен в конфиге, TypeScript подключает тайпинги (*.d.ts-файлы) для поддержки
		соответствующих спецификаций. Например, если ваш target установлен в ES6, то TypeScript подключит поддержку array.find
		и прочих вещей, которые есть в стандарте. Но если target стоит ES5, то использовать метод массива find нельзя, так как
		его не существует в этой версии JavaScript. Можно подключить полифилы. Однако, для того, чтобы TypeScript понял, что теперь
		данную функциональность можно использовать, необходимо подключить необходимые тайпинги в секции lib. При этом, можно
		подключить как весь стандарт ES2015, так и его часть ES2015.Core (только методы find, findIndex и т. д.).*/
		"outDir": "dist", //? Type: string, default: равняется корневой директории.
		/* Конечная папка, куда будут помещаться собранные артефакты. К ним относятся: .js, .d.ts, и .js.map файлы. Если не указывать
		значение для данной опции, то все вышеуказанные файлы будут повторять структуру исходных файлов в корне вашего проекта. В таком
		случае будет сложно удалять предыдущие билды и описывать .gitignore файлы. Да и кодовая база будет похожа на свалку.
		Советую складывать все артефакты в одну папку, которую легко удалить или заигнорировать системой контроля версий.*/
		"forceConsistentCasingInFileNames": true, //? Type: boolean, default: false.
		/*Включает режим чувствительности к регистру (case-sensitive) для импорта файлов. Таким образом, даже в case-insensitive файловых
		системах при попытке сделать импорт import FileManager from './FileManager.ts', если файл в действительности называется fileManager.ts,
		приведёт к ошибке. Перестраховаться лишний раз не повредит. TypeScript - это про строгость.*/
		//"outFile": "" //? Type: string, default: none.
		/* Судя по описанию, данная опция позволяет объединить все файлы в один. Кажется, что бандлеры вроде webpack больше не нужны… Однако,
		опция работает только если значение module указано None, System или AMD. К огромному сожалению, опция не будет работать с модулями
		CommonJS или ES6. Поэтому скорее всего использовать outFile не придётся. Так как опция выглядит максимально привлекательно, но
		работает не так как ожидается, я решил предупредить вас об этом гигантском подводном камне.*/
		"allowSyntheticDefaultImports": true, //? Type: boolean, default: зависит от module или esModuleInterop.
		/* Если какая-либо библиотека не имеет default import, лоадеры вроде ts-loader или babel-loader автоматически создают их.
		Однако, d.ts-файлы библиотеки об этом не знают.*/
		"esModuleInterop": true, //? Type: boolean, default: false.
		/* За счёт добавления болерплейта в выходной код, позволяет импортировать CommonJS пакеты как ES6.
		Данный флаг по зависимости активирует allowSyntheticDefaultImports. Вместе они помогают избавиться от зоопарка разных импортов
		и писать их единообразно по всему проекту.*/
		"downlevelIteration": false, //? Type: boolean, default: false.
		/* Спецификация ES6 добавила новый синтаксис для итерирования: цикл for / of, array spread, arguments spread. Если код проекта
		преобразовывается в ES5, то конструкция с циклом for / of будет преобразована в обычный for*/
		//
		//* Опции секции compilerOptions, которые нужны не в каждом проекте
		"declaration": true, //? Type: boolean, default: false.
		/* С помощью включения данного флага, помимо JavaScript файлов, к ним будут генерироваться файлы-аннотации, известные как d.ts-файлы
		или тайпинги. Благодаря тайпингам становится возможным определение типов для уже скомпилированных js файлов. Другими словами код попадает
		в js, а типы в d.ts-файлы. Это полезно в случае, например, если вы публикуете свой пакет в npm. Такой библиотекой смогут пользоваться
		разработчики, которые пишут как на чистом JavaScript, так и на TypeScript.*/
		//"declarationDir": "typings", //? Type: string, default: none, связан с declaration.
		/* По умолчанию тайпинги генерируются рядом с js-файлами. Используя данную опцию можно перенаправить все d.ts-файлы в отдельную папку.*/
		"emitDeclarationOnly": false, //? Type: boolean, default: false, связан с declaration.
		/* Если по какой-то причине вам нужны только d.ts-файлы, то включение данного флага предотвратит генерацию js-файлов.*/
		"allowJs": false, //? Type: boolean, default: false.
		/* Портировать ваш JavaScript проект на TypeScript поможет данный флаг. Активировав allowJs TypeScript компилятор будет обрабатывать не
		только ts файлы, но и js. Нет нужды полностью мигрировать проект, прежде чем продолжить его разработку. Можно это делать файл за файлом,
		просто меняя расширение и добавляя типизацию. А новый функционал сразу можно писать на TypeScript.*/
		"checkJs": false, //? Type: boolean, default: false, связан с allowJs.
		/* TypeScript будет проверять ошибки не только в ts, но и в js-файлах. Помимо встроенных тайпингов для языковых конструкций JavaScript,
		TS-компилятор так же умеет использовать jsDoc для анализа файлов. Я предпочитаю не использовать этот флаг, а наводить порядок в коде в
		момент его типизации. Однако, если в вашем проекте хорошее покрытие кода jsDoc, стоит попробовать.*/
		"experimentalDecorators": false,
		"emitDecoratorMetadata": false,
		/* Декоратор - это стандартный паттерн из мира ООП и его можно реализовывать классическим образом, создавая классы или функции-обёртки.
		Однако, с помощью двух вышеперечисленных флагов можно включить экспериментальный синтаксис декораторов. Данный синтаксис позволяет
		декорировать классы, их методы и свойства, модификаторы доступа, а так же аргументы функций используя простой и распространённый
		во многих языках программирования синтаксис @
		
		Флаг experimentalDecorators просто активирует синтаксис, а emitDecoratorMetadata в рантайме предоставляет декораторам дополнительные мета-данные,
		с помощью которых можно значительно расширить области применения данной фичи.

		Для работы emitDecoratorMetadata необходимо подтянуть в проект библиотеку reflect-metadata.*/
		"resolveJsonModule": false, //? Type: boolean, default: false.
		/*Флаг позволяет включить возможность импортировать *.json файлы. Ничего дополнительно устанавливать не требуется.*/
		"jsx": "react", //? Type: string, default: none.
		/*Если проект использует React, необходимо включить поддержку jsx. В подавляющем большинстве случаев будет достаточно опций react или react-native.
		Так же есть возможность оставить jsx-код нетронутым с помощью опции preserve или использовать кастомные преобразователи react-jsx и react-jsxdev.*/
	}
}